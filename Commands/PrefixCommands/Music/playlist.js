import { commandBuilders, EmbedBuilders } from "../../../Events/functions.js";
import { Playlist } from "../../../Events/Assets/Schemas/databases.js";
import { fileURLToPath } from 'node:url';
import path from "node:path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const generateRandomString = (length) => {
  let result = '';
  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  };
  return result;
};

const commands = new commandBuilders({
  name: path.parse(__filename).name, // T√™n L·ªánh ch√≠nh
  usage: path.parse(__filename).name, // C√°ch s·ª≠ d·ª•ng khi d√πng l·ªánh help.
  category: path.parse(__dirname).name, // th·ªÉ lo·∫°i l·ªánh
  aliases: [], // l·ªánh ph·ª•
  description: "custom playlist", // m√¥ t·∫£ d√†nh cho l·ªánh
  cooldown: 5, // th·ªùi gian h·ªìi l·ªánh
  owner: false, // b·∫≠t t·∫Øt ch·∫ø ƒë·ªô dev
  permissions: [] // quy·ªÅn h·∫°n khi s·ª≠ d·ª•ng l·ªánh
}).addCommand(async (client, message, args, prefix) => {
  const commandName = args[0]?.toLowerCase();
  if (commandName === "create") {
    const allElements = await Playlist.all();
    const playlistName = args.slice(1).join(' ');
    var findName;
    allElements.map((e) => findName = e.data.name);
    if (findName.includes(playlistName)) {
      return message.reply({ content: "ƒê√£ c√≥ t√™n playlist n√†y trong h·ªá th·ªëng vui l√≤ng s·ª≠ d·ª•ng t√™n playlist kh√°c" });
    } else {
      const randomCode = generateRandomString(30);
      await Playlist.set(randomCode, {
        GuildId: message.guild.id,
        userId: message.author.id,
        name: playlistName,
        songs: {
          url: [],
          name: []
        },
        privacy: Boolean(true),
      });
      return message.reply({
        embeds: [new EmbedBuilders({
          author: { name: client.user.username },
          title: { name: "Id playlist c·ªßa b·∫°n l√†: " + randomCode },
          description: `‚úÖ | ƒê√£ t·∫°o Playlist v·ªõi t√™n l√† **${playlistName.toUpperCase()}** ƒë∆∞·ª£c t·∫°o b·ªüi ${message.author.username}`,
          color: 0x2a9454
        })]
      });
    };
  }
  else if (commandName === "list") {
    const allPlaylist = await Playlist.all();
    const queueData = allPlaylist.map((queue, id) => {
      return [`**${id}.** ${queue.data.name.toUpperCase()} - \`${queue.ID}\``].join('\n');
    }).join('\n');
    return message.reply({
      embeds: [new EmbedBuilders({
        title: { name: "Danh s√°ch playlist c·ªßa guilds" },
        description: queueData,
        colors: "Random"
      })]
    });
  }
  else if (commandName === "delete") {
    const queueId = args[1];
    const data = await Playlist.get(queueId);
    if (!data) return message.reply({ content: 'Danh s√°ch ph√°t n√†y kh√¥ng t·ªìn t·∫°i.' });
    if (data.userId !== message.author.id) return message.reply({
      content: "B·∫°n ch·ªâ c√≥ th·ªÉ x√≥a danh s√°ch ph√°t c·ªßa ri√™ng m√¨nh"
    });
    await Playlist.delete(queueId);
    return message.reply({
      embeds: [new EmbedBuilders({
        description: `‚úÖ | ƒê√£ x√≥a th√†nh c√¥ng Danh s√°ch ph√°t c√≥ ID ƒë∆∞·ª£c li√™n k·∫øt: **${queueId}**`,
        colors: "Random"
      })]
    });
  }
  else if (commandName === "add") {
    const playlistId = args[1];
    if (!playlistId) return message.reply({ content: "Vui l√≤ng th√™m id playlist" });
    const song = args.slice(2).join(" ");
    if (!song) return message.reply({ content: "B·∫°n ch∆∞a th√™m t√™n c·ªßa b√†i h√°t vui l√≤ng th√™m t√™n b√†i h√°t" });
    const data = await Playlist.get(playlistId);
    if (!data) return message.reply({ content: 'Danh s√°ch ph√°t n√†y kh√¥ng t·ªìn t·∫°i.' });
    if (data.userId !== message.author.id) return message.reply({ content: "B·∫°n ch·ªâ c√≥ th·ªÉ th√™m c√°c b√†i h√°t v√†o danh s√°ch ph√°t c·ªßa ri√™ng m√¨nh" });
    const songData = await client.distube.search(song, {
      limit: 1
    }).catch(() => message.reply({ content: 'Kh√¥ng t√¨m th·∫•y b√†i h√°t n√†o.' }));

    const url = songData[0].url;
    const name = songData[0].name;

    if (data.songs.url.includes(url)) return message.reply({
      content: "B√†i h√°t n√†y ƒë√£ c√≥ trong danh s√°ch ph√°t"
    });

    data.songs.url.push(url);
    data.songs.name.push(name);
    await Playlist.set(playlistId, data);

    return message.reply({
      embeds: [new EmbedBuilders({
        title: { name: "üìú | Th√¥ng tin danh s√°ch ph√°t" },
        description: `‚úÖ | ƒê√£ th√™m th√†nh c√¥ng **[${name}](${url})** v√†o Danh s√°ch ph√°t`,
        colors: "Random",
      })
      ]
    });
  }
  else if (commandName === "info") {
    const queueId = args[1];
    if (!queueId) return message.reply({ content: "Vui l√≤ng nh·∫≠p th√™m playlist-id" });
    const data = await Playlist.get(queueId);
    if (!data) return message.reply({ content: `Danh s√°ch ph√°t n√†y kh√¥ng t·ªìn t·∫°i. S·ª≠ d·ª•ng \`${prefix}playlist list\` ƒë·ªÉ xem id c·ªßa danh s√°ch ph√°t` });
    const User = message.guild.members.cache.get(data.userId);
    let privacy;
    if (data.privacy === true) {
      privacy = 'Ri√™ng t∆∞';
    } else privacy = 'C√¥ng c·ªông';
    const rawFields = data.songs.name;
    let index = 1;
    const fields = rawFields.map((field) => {
      return [`**${index++}.** [${field}](${data.songs.url[index - 2]})`].join('\n');
    }).join('\n');

    return message.reply({
      embeds: [new EmbedBuilders({
        title: { name: "üìú | Th√¥ng tin danh s√°ch ph√°t" },
        description: `**T√™n:** ${data.name.toUpperCase()}\n**ID:** ${queueId}\n**Tr·∫°ng th√°i:** ${privacy}\n**B√†i h√°t:**\n ${fields}\n**ƒê∆∞·ª£c t·∫°o b·ªüi:** ${User}`,
        thumbnail: message.guild.iconURL({ dynamic: true }),
        footer: { text: 'BlackCat-Club' },
        timestamp: Date.now(),
        colors: "Random"
      })]
    });
  }
  else if (commandName === "play") {
    const { member, guild, channel } = message;
    const VoiceChannel = member.voice.channel;
    if (!VoiceChannel) return message.reply({
      content: 'üö´ | B·∫°n ph·∫£i ·ªü trong m·ªôt ph√≤ng Voice ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y !'
    });
    const queue = await client.distube.getQueue(VoiceChannel);
    if (queue && guild.members.me.voice.channelId && VoiceChannel.id !== guild.members.me.voice.channelId) return message.reply({
      content: `üö´ | B·∫°n ph·∫£i ·ªü c√πng m·ªôt ph√≤ng Voice ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y. B√†i h√°t ƒëang ƒë∆∞·ª£c ph√°t t·∫°i ${guild.members.me.voice.channel}`
    });
    const queueId = args[1];
    if (!queueId) return message.reply({ content: "Vui l√≤ng th√™m playlist-id" });
    const data = await Playlist.get(queueId);
    if (!data) return message.reply({ content: 'Danh s√°ch ph√°t kh√¥ng t·ªìn t·∫°i' });

    if (data.privacy === true) {
      const User = client.users.cache.get(data.userId);
      if (data.userId !== message.author.id) return message.reply({
        content: `Danh s√°ch n√†y ·ªü ch·∫ø ƒë·ªô private, ch·ªâ c√≥ ${User.tag} m·ªõi s·ª≠ d·ª•ng ƒë∆∞·ª£c.`
      });
      const songs = data.songs.url;
      const names = data.songs.name;
      if (!songs?.length) return message.reply({
        content: `Danh s√°ch n√†y tr·ªëng. Vui l√≤ng s·ª≠ d·ª•ng "${prefix} playlist add" ƒë·ªÉ th√™m b√†i h√°t.`
      });
      const playlist = await client.distube.createCustomPlaylist(songs, {
        member,
        properties: { name: `${names}` },
        parallel: true,
      });
      await client.distube.play(VoiceChannel, playlist, {
        textChannel: channel,
        member,
      });
      return message.channel.send({
        embeds: [new EmbedBuilders({
          description: `‚úÖ | Danh s√°ch c√≥ ID: **${queueId}** ƒë√£ ƒë∆∞·ª£c ph√°t.`,
          colors: "Random"
        })]
      });
    } else {
      const songs = data.songs.url;
      const names = data.songs.name;
      if (songs.length === 0) return message.reply({
        content: 'Danh s√°ch n√†y tr·ªëng. Vui l√≤ng s·ª≠ d·ª•ng `/playlist add` ƒë·ªÉ th√™m b√†i h√°t.'
      });
      const playlist = await client.distube.createCustomPlaylist(songs, {
        member,
        properties: { name: `${names}` },
        parallel: true,
      });
      await client.distube.play(VoiceChannel, playlist, {
        textChannel: channel,
        member,
      });
      return message.channel.send({
        embeds: [new EmbedBuilder({
          description: `‚úÖ | Danh s√°ch c√≥ ID: **${queueId}** ƒë√£ ƒë∆∞·ª£c ph√°t.`,
          colors: "Random"
        })]
      });
    };
  }
  else if (commandName === "remove") {
    const queueId = args[1];
    if (!queueId) return message.reply({ content: "Vui l√≤ng th√™m playlist-id" });
    const position = args[2];
    if (isNaN(position)) return message.reply({ content: `Gi√° tr·ªã b·∫°n v·ª´a nh·∫≠p kh√¥ng ph·∫£i l√† 1 con s·ªë` });
    const data = await Playlist.get(queueId);
    if (!data) return message.reply({ content: 'Danh s√°ch ph√°t n√†y kh√¥ng t·ªìn t·∫°i.' });
    if (data.userId !== message.author.id) return message.reply({
      content: 'B·∫°n ch·ªâ c√≥ th·ªÉ x√≥a c√°c b√†i h√°t kh·ªèi danh s√°ch ph√°t c·ªßa ri√™ng m√¨nh.'
    });

    const name = data.songs.name;
    const url = data.songs.url;

    const filtered = parseInt(position - 1);
    if (filtered > name.length - 1) return message.reply({
      content: 'Cung c·∫•p v·ªã tr√≠ b√†i h√°t h·ª£p l·ªá, s·ª≠ d·ª•ng `<prefix>playlist info` ƒë·ªÉ ki·ªÉm tra t·∫•t c·∫£ c√°c v·ªã tr√≠ b√†i h√°t'
    });

    const opName = name.splice(filtered, 1).filter((x) => !name.includes(x));
    const opURL = url.splice(filtered, 1).filter((x) => !url.includes(x));

    await Playlist.set(queueId, data);

    return message.reply({
      embeds: [new EmbedBuilders({ timestamp: Date.now() })
        .setColor('#2a9454')
        .setDescription(`‚úÖ | ƒê√£ x√≥a th√†nh c√¥ng **[${opName}](${opURL})** kh·ªèi Danh s√°ch ph√°t`)
      ]
    });
  }
  else if (commandName === "editname") {
    const playlistId = args[1];
    if (!playlistId) return message.reply({ content: "Vui l√≤ng th√™m playlist-id" });
    const newName = args.slice(2).join(" ");
    if (!newName) return message.reply({ content: "Vui l√≤ng th√™m t√™n playlist m·ªõi c·ªßa b·∫°n" });
    const data = await Playlist.get(playlistId);
    if (!data) return message.reply({ content: "Playlist kh√¥ng t·ªìn t·∫°i" });
    if (data.userId !== message.author.id) return message.reply({
      content: 'B·∫°n ch·ªâ c√≥ th·ªÉ x√≥a c√°c b√†i h√°t kh·ªèi danh s√°ch ph√°t c·ªßa ri√™ng m√¨nh.'
    });
    data.name = newName;
    await Playlist.set(playlistId, data);
    return message.reply({
      embeds: [new EmbedBuilders({
        title: { name: "S·ª≠a t√™n playlist" },
        description: `ƒê√£ s·ª≠a t√™n playlist c·ªßa b·∫°n th√†nh: ${newName}`,
        colors: "Random"
      })]
    });
  }
  else {
    return message.reply({
      embeds: [new EmbedBuilders({
        title: { name: "‚ùå Sai t√™n l·ªánh" },
        description: `
T√™n l·ªánh: | M√¥ t·∫£:
create      | t·∫°o playlist 
list             | xem danh s√°ch playlist
delete      | xo√° playlist c·ªßa b·∫°n
add           | th√™m b√†i h√°t v√†o playlist
info           | xem th√¥ng tin playlist
play          | ph√°t nh·∫°c trong playlist c·ªßa b·∫°n
        `,
        timestamp: Date.now(),
        colors: "Random"
      })]
    });
  };
});
// console.log(commands.toJSON()); // hi·ªÉn th·ªã th√¥ng tin l·ªánh ·ªü d·∫°ng JSON
export default commands;